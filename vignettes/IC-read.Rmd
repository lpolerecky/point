---
title: "IC-read"
author: "Martin Schobben and Lubos Polerecky" 
output: 
  bookdown::html_document2:
    toc: true
    number_sections: true
bibliography: SIMS.bib
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{IC-read}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", # LP: Why do we use this separator?
  warning = FALSE
)
```

# Reading Raw Ion Count Data

The function `read_IC` is used to read the raw ion count data and the accompanying metadata and collate the information into a single [tibble](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).
Currently, only data generated by the *NanoSIMS 50L* instrument are supported. The data are stored in text files with extensions *.is_txt*, *.chk_is* and *.stat*. For a study that includes analyses in multiple spots on a substrate, these files are exported in a single directory specified by the user during the analysis.

# Example

This example shows how to load the dataset *2018-01-19-GLENDON*. This dataset was generated by *NanoSIMS 50L* operated at the Department of Earth Sciences, Utrecht University. The suffix *GLENDON* corresponds to the name of the study (it stands for glendonite, which is an authigenic calcium carbonate that precipitates on the seafloor). The study comprised analyses in three spots on an in-house reference material (a belemnite rostra). The secondary ions were detected with electron multipliers (EM), and the aim of the study was to quantify the ^13^C/^12^C isotope ratio. 

## Load the required packages {-}

First, we load the *point* package:

```{r setup}
library(point) # load package
```

Second, we load additional packages that will be useful later on:

```{r additional_packages, message = FALSE}
library(dplyr)       # manipulating data
library(ggplot2)     # plot
library(polyaAeppli) # Polya-Aeppli distribution
library(purrr)       # functional programming
library(tidyr)       # tidyr data
```

## Load the complete data {-}

Because the dataset *2018-01-19-GLENDON* is bundled with the *point* package, we can use the function ``point_example`` to find the directory where it is stored:

```{r}
data_location <- point_example("2018-01-19-GLENDON")
```

Now, we are ready to load the dataset using the function `read_IC`.  In addition to the directory containing the raw ion count data, we specify `meta = TRUE` to indicate that we also want to extract the associated metadata. Also, we use `hide = TRUE` to indicate that the metadata should be included as an attribute of the output tibble. Alternatively, we can use `hide = FALSE` to include the metadata as additional columns of the output tibble. This latter option provides consistency checks between metadata and generates easily interpretable warnings. 

```{r}
tb_rw <- read_IC(data_location, meta = TRUE, hide = TRUE)
```

The output of `read_IC()` (see below) is a [tibble](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) that includes

<!--
LP: 
Here I wonder why you don't stick to your terminology. You should use "substrate" rather than "sample".
Also, I don't understand what is n.rw.
-->

* `file.nm`: the file name
* `t.nm`: time stamp of the measurement ($t_i$), in seconds
* `N.rw`: number of secondary ions detected during the measurement ($N_i$)
* `species.nm`: name of the chemical species
* `sample.nm`: name of the substrate
* `n.rw`: the total number of measurements ($n$)
* `bl.nm`: count block identifier

```{r, echo=FALSE}
(tb_rw)
```

<!--
LP: I didn't really understand the benefit of talking about the warnings if you do not provide a useful example. It might be better to just remove the text. 
-->

<!--
Warnings are used to inform that, e.g., some metadata files have no associated data files with ion counts. These files are omitted with this argument combination call to `read_IC()`.
-->

<!-- The second warning indicates that there are inconsistencies in the length $n$ of the analyses when comparing raw data and the actual rows of count data. This can indicates that an analysis was aborted leaving an incomplete ion count sequences. To figure out which file this is use the function compare_length(), which uses the `waldo` package to compare objects. -->

The metadata includes:

```{r meta}
attr(tb_rw, "metadata")
```

<!--
LP: When I type names(attr(tb_rw, "metadata")), I don't see "data" there. Btw, "date" would be a more logical name for the date. Is this perhaps a typo?
Also, I see additional columns, such as "bl.nm". What is that? Could it be that this list is not up-to-date?
-->

* `num.mt`: measurement order, in case of multiple chemical species
* `mass.mt`: the mass measured
* `det.mt`: number of the detector
* `tc.mt`: measurement time of a measurement blanked, in seconds
* `rad.mt`: radius of the mass spectrometer
* `sample.nm`: name of the substrate
* `data`: date of the analysis
* `presput.mt`: time allocated for presputtering of the analytical substrate in seconds
* `bl_num.mt`: block number
* `meas_bl.mt`: number of measurements per block
* `width_hor.mt`: horizontal Secondary Ion Beam Centering in Volts
* `width_ver.mt`: vertical Secondary Ion Beam Centering in Volts
* `prim_cur_start.mt`: Primary Ion Beam current in pico Ampere at the beginning of the analysis
* `prim_cur_after.mt`: Primary Ion Beam current in pico Ampere at the end of the analysis
* `rast_com.mt`: raster dimensions in micrometer
* `blank_rast.mt`: percentage of blanked raster
* `det_type.mt`: the type of ion counting devise; Electron Multiplier (EM) or Faraday Cup (FC) 

When the secondary ions are detected with an electron multiplier (EM), the metadata additionally includes:

<!--
LP: When I type names(attr(tb_rw, "metadata")), I see "M_PHD.mt" instead of "mean_PHD.mt". Is this perhaps a typo? Or this list is not up-to-date?
-->

* `mean_PHD.mt`: the mean pulse height amplitude (in Volts) to approximate the peak height distribution (PHD)
* `SD_PHD.mt`: the standard deviation of the pulse height amplitude (in Volts) to approximate the PHD 
* `EMHV.mt`: EM high voltage

When the secondary ions are detected with a Faraday cup (FC), the metadata additionally includes:

* `FC_start.mt`: FC background count before data acquisition
* `FC_after.mt`: FC background count after data acquisition


## Load only the metadata {-}

Function `read_meta()` can be used to only load the metadata associated with the particular study. The output is split into two tibbles. 

```{r load_metadata}
(tb_mt <- read_meta(data_location))
```

<!--
LP: Although this is a nice example of what one can do with the metadata, I find the code too complicated and outside of the scope of the point package. Also, since you do not actually show the code that you use to produce the graph, I don't find this section very illuminating. I suggest to omit it.
-->

<!--
Original text by MS, suggested to be omitted by LP:

Alternatively, one can also only extract the metadata of an analysis to, e.g., assess machine performance over a sequence of analyses. For example, one can assess the Peak Height Distribution (PHD) over a series of analyses.  


```{r PHDexample, fig.width=6, fig.height=3, fig.cap="The PHD with normalised units on the Y-axis approximated with the Polya-Aeppli density probability function with parameter $\\lambda$ and $p$ for the location and shape of the curve. These parameters can be calculated using the metadata variables mean_PHD (mean) and SD_PHD (variance), which are compiled by the read_meta function.", echo=FALSE}

tb_mt <- read_meta(point_example("2018-01-19-GLENDON"))

# The polya density distribution model to approximate PHD distributions
# install.packages("polyaAeppli")
tb_mt <- drop_na(tb_mt[[2]], M_PHD.mt, SD_PHD.mt) %>% 
  distinct(file.nm, .keep_all = TRUE) %>% 
  filter(num.mt == 1) %>%  # highest intensity counts
  mutate(PHD = map(M_PHD.mt,  ~as.integer(seq(0, 700, length = 100)))) %>%
  unnest(cols = c(PHD)) %>% 
  mutate(
    lambda = (2 * M_PHD.mt^2) / (SD_PHD.mt^2 + M_PHD.mt),
    prob = (SD_PHD.mt^2 - M_PHD.mt) / (SD_PHD.mt^2 + M_PHD.mt),
    prob = if_else(prob < 0 | prob >= 1 , NA_real_, prob),
  ) %>% 
  drop_na(lambda, prob) %>% 
  mutate(
    density = dPolyaAeppli(PHD, lambda = lambda, prob = prob),
    Y = pPolyaAeppli(50, lambda = lambda, prob = prob, lower.tail = FALSE)
  ) 

# Plot of PHD over analysis sequence
ggplot(tb_mt, aes(x = PHD, y = density)) +
  geom_line() +
  geom_text(
    aes(
      x = 500, 
      y = max(density) * 0.8, 
      label = paste("Y = ", sprintf("%0.1f", Y))
      ),
    check_overlap = TRUE
    ) +
  facet_wrap(vars(file.nm), scales = "free") +
  theme_classic()
```


The compounded Polya-Aeppli density probability function can approximate the peak height distribution  [@Dietz1970; @Dietz1978]. The package `pPolyaAeppli` [@Burden2014] together with the discriminator threshold value (usually 50 V) enables calculating the EM Yield ($Y$) (Fig. \@ref(fig:PHDexample)). More on this topic can be found in the vignette [IC-process](IC-process.html).

# References
-->
